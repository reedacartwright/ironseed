/*
# MIT License
#
# Copyright (c) 2025 Reed A. Cartwright <racartwright@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
*/

/*
# Documentation

Ironseed is a finite-entropy (or fixed-entropy) hash that can be used to
generate an unlimited sequence of seeds for initializing the state of a random
number generator. It is inspired by the work of M.E. O'Neill and others [1,2].

An ironseed is a 256-bit hash constructed from a variable-length sequence of
32-bit inputs. Each ironseed consists of eight 32-bit sub-hashes. The sub-hashes
are 32-bit multilinear hashes [3] that accumulate entropy from the input
sequence. Each input is included in every sub-hash. The coefficients for the
multilinear hashes are generated by a Weyl sequence.

Multilinear hashes are also used to generate a seed sequence from an ironseed.
Each 32-bit output value is generated by uniquely hashing the sub-hashes. The
coefficients for the output are also generated by a second Weyl sequence.

[1] https://www.pcg-random.org/posts/simple-portable-cpp-seed-entropy.html
[2] https://gist.github.com/imneme/540829265469e673d045
[3] https://arxiv.org/pdf/1202.4961.pdf
*/
#define R_NO_REMAP

#include "ironseed.h"

#include <R.h>
#include <R_ext/Rdynload.h>
#include <R_ext/Visibility.h>
#include <Rinternals.h>
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Four random primes generated by Mathematica
// NextPrime[RandomInteger[{0, 2^64-1}]]
// IntegerString[%, 16]
static const uint64_t PRIME_A = 0xc9f736a1a00d1f5full;
static const uint64_t PRIME_B = 0x88226cde0de826bfull;
static const uint64_t PRIME_C = 0x278abb429678dd43ull;
static const uint64_t PRIME_D = 0x7aa8bb10afef725bull;

// Multilinear hash (https://arxiv.org/pdf/1202.4961.pdf)
// Hash is based on a sequence of 64-bit numbers generated by Weyl sequence
// Multilinear hash is (m_0 + sum(m_i*u_i) mod 2^64) / 2^32
// m = buffer of 64-bit unsigned random values
// u = 32-bit input values that are being hashed

static inline uint64_t init_hash4i_coef() { return PRIME_A; }

static inline uint64_t hash4i_coef(uint64_t *m) { return *m += PRIME_B; }

static inline uint64_t init_hash4o_coef() { return PRIME_C; }

static inline uint64_t hash4o_coef(uint64_t *m) { return *m += PRIME_D; }

// Initialize an ironseed_hash object. Stores the intermediate values of
// 8 multilinear hashes as additional values are added to the hash.
static void init_ironseed_hash(ironseed_hash_t *p) {
  assert(p != NULL);
  p->coef = init_hash4i_coef();
  for(int i = 0; i < 8; ++i) {
    p->hashes[i] = hash4i_coef(&p->coef);
  }
}

// Update the intermediate state of each sub-hashes.
static void update_ironseed_hash(ironseed_hash_t *p, uint32_t value) {
  assert(p != NULL);
  for(int i = 0; i < 8; ++i) {
    p->hashes[i] += hash4i_coef(&p->coef) * value;
  }
}

static void update_ironseed_hash_ll(ironseed_hash_t *p, uint64_t value) {
  assert(p != NULL);
  update_ironseed_hash(p, (uint32_t)value);
  update_ironseed_hash(p, (uint32_t)(value >> 32));
}

static void update_ironseed_hash_d(ironseed_hash_t *p, double value) {
  assert(p != NULL);
  uint64_t u;
  memcpy(&u, &value, sizeof(u));
  update_ironseed_hash_ll(p, u);
}

static void update_ironseed_hash_p(ironseed_hash_t *p, void *value) {
  update_ironseed_hash_ll(p, (uint64_t)value);
}

static void update_ironseed_hash_f(ironseed_hash_t *p, DL_FUNC value) {
  update_ironseed_hash_ll(p, (uint64_t)value);
}

static void update_ironseed_hash_v(
  ironseed_hash_t *p, const void *buffer, size_t len
) {
  assert(p != NULL);
  assert(buffer != NULL);

  size_t i = 0;

  const char *b = buffer;

  for(; i + 4 < len; i += 4) {
    uint32_t u;
    memcpy(&u, b + i, 4);
    update_ironseed_hash(p, u);
  }
  uint32_t u = 0;
  memcpy(&u, b + i, len - i);
  update_ironseed_hash(p, u);
}

static void update_ironseed_hash_s(ironseed_hash_t *p, const char *s) {
  update_ironseed_hash_v(p, s, strlen(s));
}

static void create_ironseed(const ironseed_hash_t *p, ironseed_t *v) {
  assert(p != NULL);
  assert(v != NULL);

  // If the last valued hashed was 0, then it did not affect the hash
  // value. It did affect the coefficients. Append one extra value to
  // the end before we generate the result of each hash.
  uint64_t k = p->coef;
  for(int i = 0; i < 8; ++i) {
    uint64_t u = p->hashes[i] + hash4i_coef(&k);
    v->seed[i] = (uint32_t)(u >> 32);
  }
}

// defined in compat.c
uint64_t clock_entropy(void);
uint64_t pid_entropy(void);
uint64_t tid_entropy(void);
uint64_t readcycle_entropy(void);
uint64_t system_entropy(void);

// Inspired by ideas from M.E. O'Neill
// - https://www.pcg-random.org/posts/simple-portable-cpp-seed-entropy.html
// - https://gist.github.com/imneme/540829265469e673d045
static void autofill_ironseed_hash(ironseed_hash_t *p) {
  assert(p != NULL);

  // string that changes every time this file is compiled
  const char compile_stamp[] = __DATE__ __TIME__ __FILE__;
  update_ironseed_hash_s(p, compile_stamp);

  // heap and stack randomness

#ifndef __APPLE__
  void *malloc_addr = malloc(sizeof(int));
  void *stack_addr = &malloc_addr;
  update_ironseed_hash_p(p, malloc_addr);
  update_ironseed_hash_p(p, stack_addr);
  free(malloc_addr);
#endif

  // addresses of a few functions
  update_ironseed_hash_f(p, (DL_FUNC)&clock);
  update_ironseed_hash_f(p, (DL_FUNC)&getenv);
  update_ironseed_hash_f(p, (DL_FUNC)&autofill_ironseed_hash);
  update_ironseed_hash_f(p, (DL_FUNC)&Rf_allocVector);

  // time randomness
  update_ironseed_hash_ll(p, clock_entropy());

  // process id
  update_ironseed_hash_ll(p, pid_entropy());

  // thread id
  update_ironseed_hash_ll(p, tid_entropy());

  // readcyclecounter
  update_ironseed_hash_ll(p, readcycle_entropy());

  // os entropy
  update_ironseed_hash_ll(p, system_entropy());
}

static void create_seedseq(const ironseed_t *p, unsigned int *u, size_t len) {
  assert(p != NULL);
  assert(u != NULL);

  uint64_t m = init_hash4o_coef();

  for(size_t i = 0; i < len; ++i) {
    uint64_t h = hash4o_coef(&m);
    for(int i = 0; i < 8; ++i) {
      h += hash4o_coef(&m) * p->seed[i];
    }
    u[i] = (uint32_t)(h >> 32);
  }
}

SEXP R_create_ironseed(SEXP x) {
  // initialize hash
  ironseed_hash_t hash;
  init_ironseed_hash(&hash);

  // has information provided by x
  for(R_xlen_t i = 0; i < XLENGTH(x); ++i) {
    SEXP y = VECTOR_ELT(x, i);
    switch(TYPEOF(y)) {
    case INTSXP:
      for(R_xlen_t j = 0; j < XLENGTH(y); ++j) {
        update_ironseed_hash(&hash, INTEGER(y)[j]);
      }
      break;
    case REALSXP:
      for(R_xlen_t j = 0; j < XLENGTH(y); ++j) {
        update_ironseed_hash_d(&hash, REAL(y)[j]);
      }
      break;
    case LGLSXP:
      for(R_xlen_t j = 0; j < XLENGTH(y); ++j) {
        update_ironseed_hash(&hash, LOGICAL(y)[j]);
      }
      break;
    case STRSXP:
      for(R_xlen_t j = 0; j < XLENGTH(y); ++j) {
        update_ironseed_hash_s(&hash, Rf_translateCharUTF8(STRING_ELT(y, j)));
      }
      break;
    case RAWSXP:
      update_ironseed_hash_v(&hash, RAW(y), XLENGTH(y));
      break;
    case NILSXP:
      break;
    default:
      Rf_error("Ironseed hash: unsupported type `%d`", TYPEOF(y));
    }
  }

  // Construct ironseed
  ironseed_t seed;
  create_ironseed(&hash, &seed);

  SEXP ret = PROTECT(Rf_allocVector(INTSXP, 8));
  for(int i = 0; i < 8; ++i) {
    INTEGER(ret)[i] = seed.seed[i];
  }

  Rf_classgets(ret, Rf_ScalarString(Rf_mkCharCE("ironseed_ironseed", CE_UTF8)));
  UNPROTECT(1);
  return ret;
}

SEXP R_auto_ironseed() {
  ironseed_hash_t hash;
  init_ironseed_hash(&hash);
  autofill_ironseed_hash(&hash);

  ironseed_t seed;
  create_ironseed(&hash, &seed);

  SEXP ret = PROTECT(Rf_allocVector(INTSXP, 8));
  for(int i = 0; i < 8; ++i) {
    INTEGER(ret)[i] = seed.seed[i];
  }

  Rf_classgets(ret, Rf_ScalarString(Rf_mkCharCE("ironseed_ironseed", CE_UTF8)));
  UNPROTECT(1);
  return ret;
}

SEXP R_create_seedseq(SEXP x, SEXP n) {
  int len = Rf_asInteger(n);

  ironseed_t seed;
  for(int i = 0; i < 8; ++i) {
    seed.seed[i] = INTEGER(x)[i];
  }

  SEXP ret = PROTECT(Rf_allocVector(INTSXP, len));
  create_seedseq(&seed, (unsigned int *)INTEGER(ret), XLENGTH(ret));

  UNPROTECT(1);
  return ret;
}
