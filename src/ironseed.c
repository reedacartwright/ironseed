/*
# MIT License
#
# Copyright (c) 2025 Reed A. Cartwright <racartwright@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
*/

/*
# Documentation

Ironseed is a finite-entropy (or fixed-entropy) hash that can be used to
generate an unlimited sequence of seeds for initializing the state of a random
number generator. It is inspired by the work of M.E. O'Neill and others [1,2].

An ironseed is a 256-bit hash constructed from a variable-length sequence of
32-bit inputs. Each ironseed consists of eight 32-bit sub-hashes. The sub-hashes
are 32-bit multilinear hashes [3] that accumulate entropy from the input
sequence. Each input is included in every sub-hash. The coefficients for the
multilinear hashes are generated by a Weyl sequence.

Multilinear hashes are also used to generate a seed sequence from an ironseed.
Each 32-bit output value is generated by uniquely hashing the sub-hashes. The
coefficients for the output are also generated by a second Weyl sequence.

To improve the observed randomness of each hash output, bits are mixed using
a finalizer adapted from SplitMix64 [4]. With the additional mixing from the
finalizer, the output seed sequence passes PractRand tests [5].

[1] https://www.pcg-random.org/posts/developing-a-seed_seq-alternative.html
[2] https://gist.github.com/imneme/540829265469e673d045
[3] https://arxiv.org/pdf/1202.4961.pdf
[4] https://doi.org/10.1145/2714064.2660195
[5] https://pracrand.sourceforge.net/
*/
#define R_NO_REMAP

#include <R.h>
#include <R_ext/Visibility.h>
#include <Rinternals.h>
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct ironseed_entropy {
  uint64_t multiplier;
  uint64_t accumulator[8];
} ironseed_entropy_t;

typedef struct ironseed {
  uint32_t seed[8];
} ironseed_t;

/* The following constants were selected by generating four random primes in
 * Mathematica:
 *
 *     IntegerString[NextPrime[RandomInteger[{0, 2^64-1}]], 16]
 *
 * A0 is a generated prime and A1 is a generated primes multiplied by
 * two. Constants B0, B1, C0, and C1 were similarly constructed.
 *
 * These constants are used to setup two Weyl sequences that are always odd and
 * importantly never zero.
 */
static const uint64_t IRONSEED_A0 = 0xc9f736a1a00d1f5f;
static const uint64_t IRONSEED_A1 = 0x1044d9bc1bd04d7e;
static const uint64_t IRONSEED_B0 = 0x278abb429678dd43;
static const uint64_t IRONSEED_B1 = 0xf55176215fdee4b6;
static const uint64_t IRONSEED_C0 = 0x8ff2ee4eda836d2b;
static const uint64_t IRONSEED_C1 = 0xd6ac4395f26528ca;

// Adapted from mix32 of Java's SplittableRandom algorithm
// This is variant 4 of Stafford's mixing algorithms.
// http://zimbry.blogspot.com/2011/09/better-bit-mixing-improving-on.html
static inline uint32_t finalmix(uint64_t u) {
  u = (u ^ (u >> 33)) * 0x62a9d9ed799705f5;
  u = (u ^ (u >> 28)) * 0xcb24d0a5c88c35b3;
  return u >> 32;
}

// Multilinear hash (https://arxiv.org/pdf/1202.4961.pdf)
// Hash is based on a sequence of 64-bit numbers generated by Weyl sequence
// Multilinear hash is (m_0 + sum(m_i*u_i) mod 2^64) / 2^32
// m = buffer of 64-bit unsigned random values
// u = 32-bit input values that are being hashed

/* [[nodiscard]] */
static inline uint64_t accumulate_entropy(
  uint64_t* dest, size_t n, uint32_t u, uint64_t m, uint64_t c
) {
  assert(dest != NULL);
  for(size_t i = 0; i < n; ++i) {
    dest[i] += u * m;
    m += c;
  }
  return m;
}

static inline uint64_t digest_entropy(
  uint32_t* dest, const uint64_t* src, size_t n, uint32_t u, uint64_t m,
  uint64_t c
) {
  assert(dest != NULL);
  assert(src != NULL);

  // If the last valued hashed was 0, then it did not affect the hash value. It
  // did affect the coefficients. Append one extra value to the end before we
  // finalize the hash. This extra value is usually 0 (constant input lengths),
  // 1 (variable input lengths), or a salt.
  //
  // finalmix() is used here to increase the avalanche behavior of the result;
  // however it breaks the strongly universal property of the digest. If this
  // property is desired, removing this mix and mix pairs of values in dest with
  // the variant 13 mixer.
  for(size_t i = 0; i < n; ++i) {
    dest[i] = finalmix(src[i] + u * m);
    m += c;
  }
  return m;
}

// Initialize an ironseed_entropy object. Stores the intermediate values of
// 8 multilinear hashes as additional values are added to the hash.
static void init_ironseed_entropy(ironseed_entropy_t* p) {
  assert(p != NULL);
  memset(p->accumulator, 0, sizeof(p->accumulator));

  const size_t n = sizeof(p->accumulator) / sizeof(uint64_t);

  p->multiplier =
    accumulate_entropy(p->accumulator, n, 1, IRONSEED_A0, IRONSEED_A1);
}

// Update the intermediate state of each sub-digest.
static void update_ironseed_entropy(ironseed_entropy_t* p, uint32_t value) {
  assert(p != NULL);

  const size_t n = sizeof(p->accumulator) / sizeof(uint64_t);
  p->multiplier =
    accumulate_entropy(p->accumulator, n, value, p->multiplier, IRONSEED_A1);
}

// support for big-endian systems
#define byteswap32(x) __builtin_bswap32(x)
#ifndef WORDS_BIGENDIAN
#define htol32(x) (x)
#else
#define htol32(x) byteswap32(x)
#endif

static inline uint64_t dbl_as_u64(double value) {
  uint64_t u;
  memcpy(&u, &value, sizeof(u));
  return u;
}

// #nocov start
static inline uint32_t flt_as_u32(double value) {
  uint32_t u;
  memcpy(&u, &value, sizeof(u));
  return u;
}
// #nocov end

static void update_ironseed_entropy_u32(ironseed_entropy_t* p, uint32_t value) {
  update_ironseed_entropy(p, value);
}

static void update_ironseed_entropy_u64(ironseed_entropy_t* p, uint64_t value) {
  update_ironseed_entropy_u32(p, (uint32_t)value);
  update_ironseed_entropy_u32(p, (uint32_t)(value >> 32));
}

static void update_ironseed_entropy_dbl(ironseed_entropy_t* p, double value) {
  update_ironseed_entropy_u64(p, dbl_as_u64(value));
}

// #nocov start
static void update_ironseed_entropy_flt(ironseed_entropy_t* p, float value) {
  update_ironseed_entropy_u32(p, flt_as_u32(value));
}
// #nocov end

static void update_ironseed_entropy_ptr(
  ironseed_entropy_t* p, const void* value
) {
  update_ironseed_entropy_u64(p, (uint64_t)((uintptr_t)value));
}

static void
update_ironseed_entropy_fun(ironseed_entropy_t* p, void* (*value)(void)) {
  update_ironseed_entropy_u64(p, (uint64_t)((uintptr_t)value));
}

static void update_ironseed_entropy_obj(
  ironseed_entropy_t* p, const void* obj, size_t len
) {
  assert(obj != NULL);
  const uint8_t* buf = (const uint8_t*)obj;
  size_t i = 0;
  for(; i + 4 < len; i += 4) {
    uint32_t u;
    memcpy(&u, buf, sizeof(u));
    update_ironseed_entropy_u32(p, htol32(u));
    buf += 4;
  }
  uint32_t u = 0;
  memcpy(&u, buf, len - i);
  update_ironseed_entropy_u32(p, htol32(u));
}

void update_ironseed_entropy_buf(
  ironseed_entropy_t* p, const uint8_t* src, size_t len
) {
  // #nocov start
  if(src == NULL) {
    return;
  }
  // #nocov end
  update_ironseed_entropy_u32(p, (uint32_t)len);
  if(len == 0) {
    return;
  }
  update_ironseed_entropy_obj(p, src, len);
}

void update_ironseed_entropy_str(ironseed_entropy_t* p, const char* str) {
  if(str == NULL) {
    return;
  }
  update_ironseed_entropy_buf(p, (const uint8_t*)str, strlen(str));
}

static void create_ironseed(ironseed_t* dest, const ironseed_entropy_t* src) {
  assert(dest != NULL);
  assert(src != NULL);

  const size_t n = sizeof(dest->seed) / sizeof(uint32_t);
  static_assert(
    sizeof(src->accumulator) == 2 * sizeof(dest->seed),
    "src and dest must have the same number of elements"
  );

  digest_entropy(
    dest->seed, src->accumulator, n, 1, src->multiplier, IRONSEED_A1
  );
}

// defined in compat.c
uint64_t clock_entropy(void);
uint64_t pid_entropy(void);
uint64_t tid_entropy(void);
uint64_t readcycle_entropy(void);
uint64_t system_entropy(void);
void hostname_entropy(char* name, size_t size);

// Inspired by ideas from M.E. O'Neill
// - https://www.pcg-random.org/posts/simple-portable-cpp-seed-entropy.html
// - https://gist.github.com/imneme/540829265469e673d045
//
static void update_ironseed_entropy_sys(ironseed_entropy_t* p) {
  assert(p != NULL);

  char buffer[256] = "";

  // string that changes every time this file is compiled
  const char compile_stamp[] = __DATE__ __TIME__ __FILE__;
  update_ironseed_entropy_str(p, compile_stamp);

  // heap and stack randomness
  void* malloc_addr = malloc(sizeof(int));
  void* stack_addr = &malloc_addr;
  update_ironseed_entropy_ptr(p, malloc_addr);
  update_ironseed_entropy_ptr(p, stack_addr);
  free(malloc_addr);

  // addresses of a few functions
  update_ironseed_entropy_fun(p, (DL_FUNC)&clock);
  update_ironseed_entropy_fun(p, (DL_FUNC)&getenv);
  update_ironseed_entropy_fun(p, (DL_FUNC)&update_ironseed_entropy_sys);
  update_ironseed_entropy_fun(p, (DL_FUNC)&Rf_allocVector);

  // time randomness
  update_ironseed_entropy_u64(p, clock_entropy());

  // process id
  update_ironseed_entropy_u64(p, pid_entropy());

  // thread id
  update_ironseed_entropy_u64(p, tid_entropy());

  // readcyclecounter
  update_ironseed_entropy_u64(p, readcycle_entropy());

  // os entropy
  update_ironseed_entropy_u64(p, system_entropy());

  // hostname entropy
  hostname_entropy(buffer, sizeof(buffer));
  update_ironseed_entropy_str(p, buffer);

  // Job ID entropy on clusters
  const char* s;
  if((s = getenv("SLURM_JOB_ID")) != NULL) {
    update_ironseed_entropy_str(p, s);
    update_ironseed_entropy_str(p, getenv("SLURM_JOB_NAME"));
    update_ironseed_entropy_str(p, getenv("SLURM_ARRAY_TASK_ID"));
  } else if((s = getenv("PBS_JOBID")) != NULL) {
    update_ironseed_entropy_str(p, s);
    update_ironseed_entropy_str(p, getenv("PBS_JOBNAME"));
  } else if((s = getenv("LSB_JOBID")) != NULL) {
    update_ironseed_entropy_str(p, s);
    update_ironseed_entropy_str(p, getenv("LSB_JOBNAME"));
    update_ironseed_entropy_str(p, getenv("LSB_JOBINDEX"));
  } else if((s = getenv("FLUX_JOB_ID")) != NULL) {
    update_ironseed_entropy_str(p, s);
  } else if((s = getenv("JOB_ID")) != NULL) {
    update_ironseed_entropy_str(p, s);
    update_ironseed_entropy_str(p, getenv("JOB_NAME"));
    update_ironseed_entropy_str(p, getenv("SGE_TASK_ID"));
  } else if((s = getenv("AWS_BATCH_JOB_ID")) != NULL) {
    update_ironseed_entropy_str(p, s);
    update_ironseed_entropy_str(p, getenv("AWS_BATCH_JOB_ATTEMPT"));
    update_ironseed_entropy_str(p, getenv("AWS_BATCH_JOB_ARRAY_INDEX"));
  }
}

static uint64_t create_seedseq(
  unsigned int* dest, const ironseed_t* src, size_t n, uint64_t m, uint64_t c,
  uint32_t salt
) {
  assert(dest != NULL);
  assert(src != NULL);

  // This code is more complicated than it needs to be. However, I am
  // intentionally using the accumulate entropy function here, which will be
  // optimized way.
  for(size_t i = 0; i < n; ++i) {
    uint64_t v = 0;
    m = accumulate_entropy(&v, 1, 1, m, c);
    for(int j = 0; j < sizeof(src->seed) / sizeof(uint32_t); ++j) {
      m = accumulate_entropy(&v, 1, src->seed[j], m, c);
    }
    m = digest_entropy(&dest[i], &v, 1, salt, m, c);
  }
  return m;
}

SEXP R_create_ironseed(SEXP x) {
  // initialize entropy accumulator
  ironseed_entropy_t work;
  init_ironseed_entropy(&work);

  // has information provided by x
  for(R_xlen_t i = 0; i < XLENGTH(x); ++i) {
    SEXP y = VECTOR_ELT(x, i);
    switch(TYPEOF(y)) {
    case INTSXP:
      for(R_xlen_t j = 0; j < XLENGTH(y); ++j) {
        update_ironseed_entropy_u32(&work, INTEGER(y)[j]);
      }
      break;
    case REALSXP:
      for(R_xlen_t j = 0; j < XLENGTH(y); ++j) {
        update_ironseed_entropy_dbl(&work, REAL(y)[j]);
      }
      break;
    case CPLXSXP:
      for(R_xlen_t j = 0; j < XLENGTH(y); ++j) {
        update_ironseed_entropy_dbl(&work, COMPLEX(y)[j].r);
        update_ironseed_entropy_dbl(&work, COMPLEX(y)[j].i);
      }
      break;
    case LGLSXP:
      for(R_xlen_t j = 0; j < XLENGTH(y); ++j) {
        update_ironseed_entropy_u32(&work, LOGICAL(y)[j]);
      }
      break;
    case STRSXP:
      for(R_xlen_t j = 0; j < XLENGTH(y); ++j) {
        update_ironseed_entropy_str(
          &work, Rf_translateCharUTF8(STRING_ELT(y, j))
        );
      }
      break;
    case RAWSXP:
      update_ironseed_entropy_buf(&work, RAW(y), XLENGTH(y));
      break;
    case NILSXP:
      break;
    default:
      Rf_error(
        "Ironseed entropy accumulation: unsupported type `%s`",
        CHAR(Rf_type2str_nowarn(TYPEOF(y)))
      );
    }
  }

  // Construct ironseed
  ironseed_t seed;
  create_ironseed(&seed, &work);

  SEXP ret = PROTECT(Rf_allocVector(INTSXP, 8));
  for(int i = 0; i < 8; ++i) {
    INTEGER(ret)[i] = seed.seed[i];
  }

  Rf_classgets(ret, Rf_ScalarString(Rf_mkCharCE("ironseed_ironseed", CE_UTF8)));
  UNPROTECT(1);
  return ret;
}

SEXP R_auto_ironseed(void) {
  ironseed_entropy_t work;
  init_ironseed_entropy(&work);
  update_ironseed_entropy_sys(&work);

  ironseed_t seed;
  create_ironseed(&seed, &work);

  SEXP ret = PROTECT(Rf_allocVector(INTSXP, 8));
  for(int i = 0; i < 8; ++i) {
    INTEGER(ret)[i] = seed.seed[i];
  }

  Rf_classgets(ret, Rf_ScalarString(Rf_mkCharCE("ironseed_ironseed", CE_UTF8)));
  UNPROTECT(1);
  return ret;
}

SEXP R_create_seedseq(SEXP x, SEXP n, SEXP salt, SEXP m) {
  union {
    uint64_t u;
    double d;
  } mm = {IRONSEED_B0};

  int len = Rf_asInteger(n);

  if(!Rf_isNull(m)) {
    mm.d = Rf_asReal(m);
  }

  ironseed_t seed;
  for(int i = 0; i < 8; ++i) {
    seed.seed[i] = INTEGER(x)[i];
  }

  SEXP ret = PROTECT(Rf_allocVector(INTSXP, len));

  mm.u = create_seedseq(
    (unsigned int*)INTEGER(ret), &seed, XLENGTH(ret), mm.u, IRONSEED_B1,
    (uint32_t)Rf_asInteger(salt)
  );

  Rf_setAttrib(ret, Rf_install("m"), Rf_ScalarReal(mm.d));

  UNPROTECT(1);
  return ret;
}

SEXP R_create_digests(SEXP x, SEXP n, SEXP salt) {
  int ret_len = Rf_asInteger(n);
  int nsalt = Rf_asInteger(salt);

  size_t dat_len;
  const uint8_t* dat;

  // x is raw or a string or can be converted to a string
  if(TYPEOF(x) == RAWSXP) {
    dat = (const uint8_t*)RAW_RO(x);
    dat_len = Rf_xlength(x);
  } else {
    const char* s = Rf_translateCharUTF8(Rf_asChar(x));
    dat = (const uint8_t*)s;
    dat_len = strlen(s);
  }

  // Allocate and initialize entropy accumulator
  SEXP work = PROTECT(Rf_allocVector(REALSXP, ret_len));
  uint64_t* pwork = (uint64_t*)REAL(work);
  memset(pwork, 0, sizeof(uint64_t) * ret_len);
  uint64_t m = accumulate_entropy(pwork, ret_len, 1, IRONSEED_C0, IRONSEED_C1);

  // Include the length of the input in the accumulator
  m = accumulate_entropy(pwork, ret_len, (uint32_t)dat_len, m, IRONSEED_C1);

  // Hash input as 32-bit blocks
  size_t i = 0;
  for(; i + 4 < dat_len; i += 4) {
    uint32_t u;
    memcpy(&u, dat, sizeof(u));
    m = accumulate_entropy(pwork, ret_len, htol32(u), m, IRONSEED_C1);
    dat += 4;
  }
  // Hash remainder.
  uint32_t u = 0;
  memcpy(&u, dat, dat_len - i);
  m = accumulate_entropy(pwork, ret_len, htol32(u), m, IRONSEED_C1);

  // Create digests.
  SEXP ret = PROTECT(Rf_allocVector(INTSXP, ret_len));
  digest_entropy(
    (uint32_t*)INTEGER(ret), pwork, ret_len, nsalt, m, IRONSEED_C1
  );

  UNPROTECT(2);
  return ret;
}
